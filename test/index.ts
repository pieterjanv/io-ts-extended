import * as t from '../src/index.js';

interface Brand {
	readonly Brand: unique symbol;
}

interface T {
	a: string;
	b: T | number;
}

const myClss = t.clss(
	'T',
	t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: t.boolean }),
	t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: t.boolean }),
	class extends t.Implementation {
		static a: string = 'foo';
		static b(a: string): boolean { return true; };
		static c: boolean = false;;
		a: string = 'foo';
		b(a: string): boolean { return true; };
		c: boolean = false;
	});

// Array of test cases. Each case is a tuple of [source, target, expected].
const tests1: Array<readonly [t.Type<unknown>, t.Type<unknown>, boolean]> = [

	// t.AnyArrayType
	[new t.AnyArrayType, new t.AnyArrayType, true],
	[new t.AnyDictionaryType, new t.AnyArrayType, false],
	[t.any, new t.AnyArrayType, false],
	[t.array(t.unknown), new t.AnyArrayType, true],
	[t.bigint, new t.AnyArrayType, false],
	[t.boolean, new t.AnyArrayType, false],
	[myClss, new t.AnyArrayType, false],
	[t.record(t.string, t.string), new t.AnyArrayType, false],
	[t.exact(t.type({ a: t.string })), new t.AnyArrayType, false],
	[t.fn([['a', t.string]] as const, t.boolean), new t.AnyArrayType, false],
	[t.type({ a: t.string }), new t.AnyArrayType, false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), new t.AnyArrayType, false],
	[t.intersection([t.array(t.number), t.tuple([t.string])]), new t.AnyArrayType, true],
	[t.keyof({ a: null, b: null }), new t.AnyArrayType, false],
	[t.literal('a'), new t.AnyArrayType, false],
	[t.never, new t.AnyArrayType, true],
	[t.null, new t.AnyArrayType, false],
	[t.number, new t.AnyArrayType, false],
	[t.partial({ a: t.string }), new t.AnyArrayType, false],
	[t.readonlyArray(t.string), new t.AnyArrayType, false],
	[t.readonly(t.tuple([t.string, t.number])), new t.AnyArrayType, false],
	[t.recursion('T', (self) => t.tuple([t.string, self])), new t.AnyArrayType, true],
	[t.brand(new t.AnyArrayType, (x): x is t.Branded<unknown[], Brand> => true, 'Brand'), new t.AnyArrayType, true],
	[t.string, new t.AnyArrayType, false],
	[t.tuple([t.string, t.number]), new t.AnyArrayType, true],
	[t.undefined, new t.AnyArrayType, false],
	[t.union([t.array(t.string), t.array(t.number)]), new t.AnyArrayType, true],
	[t.unknown, new t.AnyArrayType, false],
	[t.void, new t.AnyArrayType, false],
	[t.nullable(new t.AnyArrayType), new t.AnyArrayType, false],
	[t.promise(new t.AnyArrayType), new t.AnyArrayType, false],

	// t.AnyDictionaryType
	[new t.AnyArrayType, new t.AnyDictionaryType, false],
	[new t.AnyDictionaryType, new t.AnyDictionaryType, true],
	[t.any, new t.AnyDictionaryType, false],
	[t.array(t.unknown), new t.AnyDictionaryType, false],
	[t.bigint, new t.AnyDictionaryType, false],
	[t.boolean, new t.AnyDictionaryType, false],
	[myClss, new t.AnyDictionaryType, true],
	[t.record(t.string, t.string), new t.AnyDictionaryType, true],
	[t.exact(t.type({ a: t.string })), new t.AnyDictionaryType, true],
	[t.fn([['a', t.string]] as const, t.boolean), new t.AnyDictionaryType, false],
	[t.type({ a: t.string }), new t.AnyDictionaryType, true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), new t.AnyDictionaryType, true],
	[t.keyof({ a: null, b: null }), new t.AnyDictionaryType, false],
	[t.literal('a'), new t.AnyDictionaryType, false],
	[t.never, new t.AnyDictionaryType, true],
	[t.null, new t.AnyDictionaryType, false],
	[t.number, new t.AnyDictionaryType, false],
	[t.partial({ a: t.string }), new t.AnyDictionaryType, true],
	[t.readonlyArray(t.string), new t.AnyDictionaryType, false],
	[t.readonly(t.type({ a: t.string })), new t.AnyDictionaryType, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), new t.AnyDictionaryType, true],
	[t.brand(new t.AnyDictionaryType, (x): x is t.Branded<Record<string, unknown>, Brand> => true, 'Brand'), new t.AnyDictionaryType, true],
	[t.string, new t.AnyDictionaryType, false],
	[t.tuple([t.string, t.number]), new t.AnyDictionaryType, false],
	[t.undefined, new t.AnyDictionaryType, false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), new t.AnyDictionaryType, true],
	[t.unknown, new t.AnyDictionaryType, false],
	[t.void, new t.AnyDictionaryType, false],
	[t.nullable(new t.AnyDictionaryType), new t.AnyDictionaryType, false],
	[t.promise(new t.AnyDictionaryType), new t.AnyDictionaryType, false],

	// t.Any
	[new t.AnyArrayType, t.any, true],
	[new t.AnyDictionaryType, t.any, true],
	[t.any, t.any, true],
	[t.array(t.unknown), t.any, true],
	[t.bigint, t.any, true],
	[t.boolean, t.any, true],
	[myClss, t.any, true],
	[t.record(t.string, t.string), t.any, true],
	[t.exact(t.type({ a: t.string })), t.any, true],
	[t.fn([['a', t.string]] as const, t.boolean), t.any, true],
	[t.type({ a: t.string }), t.any, true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.any, true],
	[t.keyof({ a: null, b: null }), t.any, true],
	[t.literal('a'), t.any, true],
	[t.never, t.any, true],
	[t.null, t.any, true],
	[t.number, t.any, true],
	[t.partial({ a: t.string }), t.any, true],
	[t.readonlyArray(t.string), t.any, true],
	[t.readonly(t.type({ a: t.string })), t.any, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.any, true],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.any, true],
	[t.string, t.any, true],
	[t.tuple([t.string, t.number]), t.any, true],
	[t.undefined, t.any, true],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.any, true],
	[t.unknown, t.any, true],
	[t.void, t.any, true],
	[t.nullable(t.any), t.any, true],
	[t.promise(t.any), t.any, true],

	// t.ArrayType
	[new t.AnyArrayType, t.array(t.string), false],
	[new t.AnyDictionaryType, t.array(t.string), false],
	[t.any, t.array(t.string), false],
	[t.array(t.unknown), t.array(t.string), false],
	[t.array(t.literal('s')), t.array(t.string), true],
	[t.bigint, t.array(t.string), false],
	[t.boolean, t.array(t.string), false],
	[myClss, t.array(t.string), false],
	[t.record(t.string, t.string), t.array(t.string), false],
	[t.exact(t.type({ a: t.string })), t.array(t.string), false],
	[t.fn([['a', t.string]] as const, t.boolean), t.array(t.string), false],
	[t.type({ a: t.string }), t.array(t.string), false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.array(t.string), false],
	[t.intersection([t.array(t.literal('s')), t.array(t.string)]), t.array(t.string), true],
	[t.intersection([t.array(t.string), t.readonlyArray(t.string)]), t.array(t.string), true],
	[t.intersection([t.array(t.number), t.tuple([t.string])]), t.array(t.unknown), true],
	[t.intersection([t.array(t.number), t.tuple([t.string])]), t.array(t.string), true],
	[t.intersection([t.array(t.number), t.tuple([t.string])]), t.array(t.boolean), false],
	[t.keyof({ a: null, b: null }), t.array(t.string), false],
	[t.literal('a'), t.array(t.string), false],
	[t.never, t.array(t.string), true],
	[t.null, t.array(t.string), false],
	[t.number, t.array(t.string), false],
	[t.partial({ a: t.string }), t.array(t.string), false],
	[t.readonlyArray(t.string), t.array(t.string), false],
	[t.readonly(t.type({ a: t.string })), t.array(t.string), false],
	[t.readonly(t.array(t.string)), t.array(t.string), false],
	[t.recursion('T', (self) => t.array(t.union([self, t.string]))), t.array(t.string), false],
	[t.recursion('T', (self) => t.readonlyArray(t.union([self, t.string]))), t.recursion('T2', (self) => t.readonlyArray(t.union([self, t.string, t.number]))), true],
	[t.brand(t.array(t.string), (x): x is t.Branded<string[], Brand> => true, 'Brand'), t.array(t.string), true],
	[t.string, t.array(t.string), false],
	[t.tuple([t.string, t.number]), t.array(t.string), false],
	[t.tuple([t.string]), t.array(t.string), true],
	[t.undefined, t.array(t.string), false],
	[t.union([t.array(t.string), t.array(t.number)]), t.array(t.string), false],
	[t.union([t.array(t.string), t.readonlyArray(t.string)]), t.array(t.string), false],
	[t.unknown, t.array(t.string), false],
	[t.void, t.array(t.string), false],
	[t.nullable(t.array(t.string)), t.array(t.string), false],
	[t.promise(t.array(t.string)), t.array(t.string), false],

	// t.BigIntType
	[new t.AnyArrayType, t.bigint, false],
	[new t.AnyDictionaryType, t.bigint, false],
	[t.any, t.bigint, false],
	[t.array(t.unknown), t.bigint, false],
	[t.array(t.literal('s')), t.bigint, false],
	[t.bigint, t.bigint, true],
	[t.boolean, t.bigint, false],
	[myClss, t.bigint, false],
	[t.record(t.string, t.string), t.bigint, false],
	[t.exact(t.type({ a: t.string })), t.bigint, false],
	[t.fn([['a', t.string]] as const, t.boolean), t.bigint, false],
	[t.type({ a: t.string }), t.bigint, false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.bigint, false],
	[t.intersection([t.bigint, t.never]), t.bigint, true],
	[t.keyof({ a: null, b: null }), t.bigint, false],
	[t.literal('a'), t.bigint, false],
	[t.never, t.bigint, true],
	[t.null, t.bigint, false],
	[t.number, t.bigint, false],
	[t.partial({ a: t.string }), t.bigint, false],
	[t.readonlyArray(t.string), t.bigint, false],
	[t.readonly(t.bigint), t.bigint, true],
	[t.recursion('T', (self) => t.array(t.union([self, t.string]))), t.bigint, false],
	[t.brand(t.bigint, (x): x is t.Branded<bigint, Brand> => true, 'Brand'), t.bigint, true],
	[t.string, t.bigint, false],
	[t.tuple([t.string, t.number]), t.bigint, false],
	[t.tuple([t.string]), t.bigint, false],
	[t.undefined, t.bigint, false],
	[t.union([t.bigint, t.never]), t.bigint, true],
	[t.unknown, t.bigint, false],
	[t.void, t.bigint, false],
	[t.nullable(t.bigint), t.bigint, false],
	[t.promise(t.bigint), t.bigint, false],

	// t.BooleanType
	[new t.AnyArrayType, t.boolean, false],
	[new t.AnyDictionaryType, t.boolean, false],
	[t.any, t.boolean, false],
	[t.array(t.unknown), t.boolean, false],
	[t.bigint, t.boolean, false],
	[t.boolean, t.boolean, true],
	[myClss, t.boolean, false],
	[t.record(t.string, t.string), t.boolean, false],
	[t.exact(t.type({ a: t.string })), t.boolean, false],
	[t.fn([['a', t.string]] as const, t.boolean), t.boolean, false],
	[t.type({ a: t.string }), t.boolean, false],
	[t.intersection([t.boolean, t.literal(false)]), t.boolean, true],
	[t.keyof({ a: null, b: null }), t.boolean, false],
	[t.literal(true), t.boolean, true],
	[t.never, t.boolean, true],
	[t.null, t.boolean, false],
	[t.number, t.boolean, false],
	[t.partial({ a: t.string }), t.boolean, false],
	[t.readonlyArray(t.string), t.boolean, false],
	[t.readonly(t.boolean), t.boolean, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.boolean, false],
	[t.brand(t.boolean, (x): x is t.Branded<boolean, Brand> => true, 'Brand'), t.boolean, true],
	[t.string, t.boolean, false],
	[t.tuple([t.string, t.number]), t.boolean, false],
	[t.undefined, t.boolean, false],
	[t.union([t.boolean, t.literal(false)]), t.boolean, true],
	[t.unknown, t.boolean, false],
	[t.void, t.boolean, false],
	[t.nullable(t.boolean), t.boolean, false],
	[t.promise(t.boolean), t.boolean, false],

	// t.ClssType
	[new t.AnyArrayType, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[new t.AnyDictionaryType, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.any, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.array(t.unknown), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.bigint, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.boolean, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[myClss, myClss, true],
	[myClss, t.clss('U', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: t.boolean }), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: t.boolean }), class extends myClss.ctor {}), true],
	[t.clss('V', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: t.boolean }), class extends myClss.ctor {}), myClss, false],
	[t.clss('W', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: t.boolean }), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends myClss.ctor {}), myClss, false],
	[t.clss('X', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: t.boolean }), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: t.boolean }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true; }; static c: false; a: string = 'foo'; b(a: string): boolean { return true; }; c: boolean = false }), myClss, true],
	[t.extendClss('Y', myClss, t.type({ d: t.string }), t.type({ d: t.string }), class extends myClss.ctor { static d: string = 'd'; d: string = 'd' }), myClss, true],
	[t.record(t.string, t.string), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.exact(t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) })), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.fn([['a', t.string]] as const, t.boolean), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.type({ a: t.string, b: t.fn([['a', t.number]] as const, t.boolean) }), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.intersection([t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), t.type({ c: t.number })]), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.intersection([myClss, t.type({ a: t.literal('s') })]), myClss, true],
	[t.keyof({ a: null, b: null }), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.literal('a'), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.never, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), true],
	[t.null, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.number, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.partial({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.readonlyArray(t.string), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.readonly(t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) })), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.readonly(myClss), myClss, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: self })), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.recursion('T', (self) => t.extendClss('T', myClss, t.type({}), t.type({ d: self }), class extends myClss.ctor { d: this = this })), myClss, true],
	[t.brand(t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), (x): x is t.Branded<{ a: string, b: (a: string) => boolean }, Brand> => true, 'Brand'), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.brand(myClss, (x): x is t.Branded<t.TypeOf<typeof myClss>, Brand> => true, 'Brand'), myClss, true],
	[t.string, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.tuple([t.string, t.number]), t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.undefined, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.union([myClss, t.extendClss('Z', myClss, t.type({}), t.type({ a: t.literal('s') }), class extends myClss.ctor { a: 's' = 's' })]), myClss, true],
	[t.unknown, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.void, t.clss('T', t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean)}), t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean) }), class extends t.Implementation { static a: string = 'foo'; static b(a: string): boolean { return true }; a: string = 'foo'; b(a: string): boolean { return true; }}), false],
	[t.nullable(myClss), myClss, false],
	[t.promise(myClss), myClss, false],

	// t.DictionaryType
	[new t.AnyArrayType, t.record(t.string, t.string), false],
	[new t.AnyDictionaryType, t.record(t.string, t.unknown), true],
	[new t.AnyDictionaryType, t.record(t.number, t.unknown), true],
	[new t.AnyDictionaryType, t.record(t.string, t.string), false],
	[t.any, t.record(t.string, t.string), false],
	[t.array(t.unknown), t.record(t.string, t.string), false],
	[t.bigint, t.record(t.string, t.string), false],
	[t.boolean, t.record(t.string, t.string), false],
	[myClss, t.record(t.string, t.unknown), true],
	[t.record(t.string, t.string), t.record(t.string, t.string), true],
	[t.exact(t.type({ a: t.string })), t.record(t.string, t.string), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.record(t.string, t.string), false],
	[t.type({ a: t.string }), t.record(t.string, t.string), true],
	[t.type({ a: t.number }), t.record(t.string, t.string), false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.record(t.string, t.string), false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.record(t.string, t.union([t.string, t.number])), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.record(t.string, t.union([t.intersection([t.string, t.union([t.never, t.unknown])]), t.number])), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.record(t.string, t.union([t.intersection([t.string, t.union([t.never, t.boolean])]), t.number])), false],
	[t.keyof({ a: null, b: null }), t.record(t.string, t.string), false],
	[t.literal('a'), t.record(t.string, t.string), false],
	[t.never, t.record(t.string, t.string), true],
	[t.null, t.record(t.string, t.string), false],
	[t.number, t.record(t.string, t.string), false],
	[t.partial({ a: t.string }), t.record(t.string, t.string), true],
	[t.readonlyArray(t.string), t.record(t.string, t.string), false],
	[t.readonly(t.type({ a: t.string })), t.record(t.string, t.string), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.record(t.string, t.string), false],
	[t.brand(t.record(t.string, t.string), (x): x is t.Branded<Record<string, string>, Brand> => true, 'Brand'), t.record(t.string, t.string), true],
	[t.string, t.record(t.string, t.string), false],
	[t.tuple([t.string, t.number]), t.record(t.string, t.string), false],
	[t.undefined, t.record(t.string, t.string), false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.record(t.string, t.string), false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.record(t.string, t.union([t.string, t.number])), true],
	[t.unknown, t.record(t.string, t.string), false],
	[t.void, t.record(t.string, t.string), false],
	[t.intersection([t.type({ a: t.literal('s') }), t.type({ b: t.literal(5) }), t.union([t.record(t.string, t.literal('s')), t.type({ b: t.number })])]), t.record(t.string, t.union([t.literal('s'), t.literal(5)])), true],
	[t.nullable(t.record(t.string, t.string)), t.record(t.string, t.string), false],
	[t.promise(t.record(t.string, t.string)), t.record(t.string, t.string), false],

	// t.ExactType
	[new t.AnyArrayType, t.exact(t.type({ a: t.string })), false],
	[new t.AnyDictionaryType, t.exact(t.type({ a: t.string })), false],
	[t.any, t.exact(t.type({ a: t.string })), false],
	[t.array(t.unknown), t.exact(t.type({ a: t.string })), false],
	[t.bigint, t.exact(t.type({ a: t.string })), false],
	[t.boolean, t.exact(t.type({ a: t.string })), false],
	[myClss, t.exact(t.type({ a: t.string, b: t.fn([['a', t.string]] as const, t.boolean), c: t.boolean })), true],
	[t.record(t.string, t.string), t.exact(t.type({})), false],
	[t.record(t.string, t.string), t.exact(t.type({ a: t.string })), false],
	[t.exact(t.type({ a: t.string })), t.exact(t.type({ a: t.string })), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.type({ a: t.string }), false],
	[t.type({ a: t.string }), t.exact(t.type({ a: t.string })), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.exact(t.type({ a: t.string })), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.exact(t.type({ a: t.string, b: t.number })), true],
	[t.keyof({ a: null, b: null }), t.exact(t.type({ a: t.string })), false],
	[t.literal('a'), t.exact(t.type({ a: t.string })), false],
	[t.never, t.exact(t.type({ a: t.string })), true],
	[t.null, t.exact(t.type({ a: t.string })), false],
	[t.number, t.exact(t.type({ a: t.string })), false],
	[t.partial({ a: t.string }), t.exact(t.type({ a: t.string })), false],
	[t.partial({}), t.exact(t.type({})), true],
	[t.readonlyArray(t.string), t.exact(t.type({ a: t.string })), false],
	[t.readonly(t.type({ a: t.string })), t.exact(t.type({ a: t.string })), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.exact(t.type({ a: t.string })), true],
	[t.brand(t.type({a: t.string}), (x): x is t.Branded<{a: string}, Brand> => true, 'Brand'), t.exact(t.type({ a: t.string })), true],
	[t.string, t.exact(t.type({ a: t.string })), false],
	[t.tuple([t.string, t.number]), t.exact(t.type({ a: t.string })), false],
	[t.undefined, t.exact(t.type({ a: t.string })), false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.exact(t.type({ a: t.string })), false],
	[t.union([t.type({ a: t.string }), t.type({ a: t.number })]), t.exact(t.type({ a: t.union([t.string, t.number]) })), true],
	[t.unknown, t.exact(t.type({ a: t.string })), false],
	[t.void, t.exact(t.type({ a: t.string })), false],
	[t.nullable(t.exact(t.type({ a: t.string }))), t.exact(t.type({ a: t.string })), false],
	[t.promise(t.exact(t.type({ a: t.string }))), t.exact(t.type({ a: t.string })), false],

	// FunctionType
	[new t.AnyArrayType, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[new t.AnyDictionaryType, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.any, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.array(t.unknown), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.bigint, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[myClss, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.boolean, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.record(t.string, t.string), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.exact(t.type({ a: t.string })), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.fn([['a', t.union([t.string, t.number])]] as const, t.literal(true)), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.fn([['a', t.literal('s')]] as const, t.boolean), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.type({ a: t.string }), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.intersection([t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.unknown]] as const, t.boolean)]), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.intersection([t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.literal('s')]] as const, t.boolean)]), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.intersection([t.fn([['a', t.number]] as const, t.boolean), t.fn([['a', t.literal('s')]] as const, t.boolean)]), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.keyof({ a: null, b: null }), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.literal('a'), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.never, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.null, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.number, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.partial({ a: t.string }), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.readonlyArray(t.string), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.readonly(t.fn([['a', t.string], ['b', t.number]] as const, t.boolean)), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.recursion('T', (self) => t.fn([['a', t.string], ['b', self]] as const, t.boolean)), t.fn([['a', t.string]] as const, t.boolean), false],
	[t.recursion('T', (self) => t.fn([['a', t.string], ['b', self]] as const, t.boolean)), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.recursion('T', (self) => t.fn([['a', t.string], ['b', self]] as const, t.boolean)), t.fn([['a', t.string], ['b', t.fn([['a', t.string]] as const, t.boolean)]] as const, t.boolean), true],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.string, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.tuple([t.string, t.number]), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.undefined, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.union([t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.unknown]] as const, t.boolean)]), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), true],
	[t.union([t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.literal(5)]] as const, t.boolean)]), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.unknown, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.void, t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.nullable(t.fn([['a', t.string], ['b', t.number]] as const, t.boolean)), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],
	[t.promise(t.fn([['a', t.string], ['b', t.number]] as const, t.boolean)), t.fn([['a', t.string], ['b', t.number]] as const, t.boolean), false],

	// t.InterfaceType
	[new t.AnyArrayType, t.type({ a: t.string }), false],
	[new t.AnyDictionaryType, t.type({ a: t.string }), false],
	[t.any, t.type({ a: t.string }), false],
	[t.array(t.unknown), t.type({ a: t.string }), false],
	[t.bigint, t.type({ a: t.string }), false],
	[t.boolean, t.type({ a: t.string }), false],
	[myClss, t.type({ a: t.string }), true],
	[t.record(t.string, t.string), (t.type({})), false],
	[t.record(t.string, t.string), t.type({ a: t.string }), false],
	[(t.type({ a: t.string })), t.type({ a: t.string }), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.type({ a: t.string }), false],
	[t.type({ a: t.string }), (t.type({ a: t.string })), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), (t.type({ a: t.string })), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), (t.type({ a: t.string, b: t.number })), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.type({}), true],
	[t.intersection([t.number, t.literal(1)]), t.type({}), false],
	[t.keyof({ a: null, b: null }), t.type({ a: t.string }), false],
	[t.literal('a'), t.type({ a: t.string }), false],
	[t.never, (t.type({ a: t.string })), true],
	[t.null, t.type({ a: t.string }), false],
	[t.number, t.type({ a: t.string }), false],
	[t.partial({ a: t.string }), t.type({ a: t.string }), false],
	[t.partial({}), (t.type({})), true],
	[t.readonlyArray(t.string), t.type({ a: t.string }), false],
	[t.readonly(t.type({ a: t.string })), (t.type({ a: t.string })), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), (t.type({ a: t.string })), true],
	[t.brand(t.type({a: t.string}), (x): x is t.Branded<{a: string}, Brand> => true, 'Brand'), (t.type({ a: t.string })), true],
	[t.string, t.type({ a: t.string }), false],
	[t.tuple([t.string, t.number]), t.type({ a: t.string }), false],
	[t.undefined, t.type({ a: t.string }), false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.type({ a: t.string }), false],
	[t.union([t.type({ a: t.string }), t.type({ a: t.number })]), (t.type({ a: t.union([t.string, t.number]) })), true],
	[t.unknown, t.type({ a: t.string }), false],
	[t.void, t.type({ a: t.string }), false],
	[t.nullable(t.type({ a: t.string })), t.type({ a: t.string }), false],
	[t.promise(t.type({ a: t.string })), t.type({ a: t.string }), false],
];

const tests2: Array<readonly [t.Type<unknown>, t.Type<unknown>, boolean]> = [
	// t.IntersectionType
	[new t.AnyArrayType, t.intersection([t.array(t.any), t.array(t.unknown)]), true],
	[new t.AnyArrayType, t.intersection([t.array(t.any), t.array(t.string)]), false],
	[new t.AnyDictionaryType, t.intersection([t.record(t.string, t.unknown), t.record(t.number, t.any)]), true],
	[new t.AnyDictionaryType, t.intersection([t.record(t.string, t.string), t.record(t.number, t.any)]), false],
	[t.any, t.intersection([t.string, t.unknown]), false],
	[t.array(t.literal(5)), t.intersection([t.array(t.number), t.array(t.literal(5))]), true],
	[t.array(t.literal(5)), t.intersection([t.array(t.number), t.array(t.literal('s'))]), false],
	[t.bigint, t.intersection([t.bigint, t.unknown]), true],
	[t.boolean, t.intersection([t.boolean, t.union([t.literal(false), t.literal(true)])]), true],
	[t.boolean, t.intersection([t.boolean, t.literal(false)]), false],
	[myClss, t.intersection([t.type({ a: t.string }), t.type({ c: t.boolean })]), true],
	[myClss, t.intersection([t.type({ a: t.string }), t.type({ d: t.boolean })]), false],
	[t.record(t.string, t.literal('s')), t.intersection([t.record(t.string, t.string), t.record(t.string, t.literal('s'))]), true],
	[t.exact(t.type({ a: t.string })), t.intersection([t.type({ a: t.string }), t.type({ a: t.number })]), false],
	[t.exact(t.type({ a: t.string })), t.intersection([t.type({ a: t.string }), t.type({ a: t.string })]), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.intersection([t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.unknown]] as const, t.boolean)]), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.intersection([t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.literal('s')]] as const, t.boolean)]), true],
	[t.type({ a: t.string }), t.intersection([t.type({ a: t.string }), t.type({ a: t.string })]), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number, c: t.boolean })]), t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), true],
	[t.keyof({ a: null, b: null }), t.intersection([t.literal('a'), t.literal('b')]), false],
	[t.literal('a'), t.intersection([t.string, t.literal('a')]), true],
	[t.never, t.intersection([t.string, t.never]), true],
	[t.null, t.intersection([t.string, t.null]), false],
	[t.number, t.intersection([t.string, t.number]), false],
	[t.number, t.intersection([t.unknown, t.number]), true],
	[t.partial({ a: t.string }), t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), false],
	[t.readonlyArray(t.string), t.intersection([t.array(t.string), t.array(t.unknown)]), false],
	[t.readonly(t.type({ a: t.string, b: t.number })), t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.intersection([t.type({ a: t.string }), t.type({ b: t.type({ a: t.string })})]), true],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.intersection([t.number, t.unknown]), true],
	[t.string, t.intersection([t.string, t.string]), true],
	[t.tuple([t.string, t.number]), t.intersection([t.tuple([t.string, t.unknown]), t.tuple([t.unknown, t.number])]), true],
	[t.undefined, t.intersection([t.string, t.undefined]), false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.intersection([t.type({ a: t.string}), t.type({ b: t.number})]), false],
	[t.unknown, t.intersection([t.string, t.unknown]), false],
	[t.void, t.intersection([t.string, t.void]), false],
	[t.nullable(t.undefined), t.intersection([t.undefined, t.undefined]), false],
	[t.nullable(t.intersection([t.undefined, t.undefined])), t.intersection([t.undefined, t.undefined]), false],
	[t.promise(t.string), t.intersection([t.promise(t.string), t.promise(t.string)]), true],
	[t.promise(t.intersection([t.undefined, t.undefined])), t.intersection([t.undefined, t.undefined]), false],

	// t.KeyOfType
	[new t.AnyArrayType, t.keyof({ a: null, b: null }), false],
	[new t.AnyDictionaryType, t.keyof({ a: null, b: null }), false],
	[t.any, t.keyof({ a: null, b: null }), false],
	[t.array(t.unknown), t.keyof({ a: null, b: null }), false],
	[t.bigint, t.keyof({ a: null, b: null }), false],
	[t.boolean, t.keyof({ a: null, b: null }), false],
	[myClss, t.keyof({ a: null, b: null }), false],
	[t.record(t.string, t.string), t.keyof({ a: null, b: null }), false],
	[t.exact(t.type({ a: t.string })), t.keyof({ a: null, b: null }), false],
	[t.fn([['a', t.string]] as const, t.boolean), t.keyof({ a: null, b: null }), false],
	[t.type({ a: t.string }), t.keyof({ a: null, b: null }), false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.keyof({ a: null, b: null }), false],
	[t.keyof({ a: null, b: null }), t.keyof({ a: null, b: null }), true],
	[t.keyof({ a: null }), t.keyof({ a: null, b: null }), true],
	[t.literal('a'), t.keyof({ a: null, b: null }), true],
	[t.literal(1), t.keyof({ 1: null, b: null }), false],
	[t.literal('1'), t.keyof({ 1: null, b: null }), true],
	[t.never, t.keyof({ a: null, b: null }), true],
	[t.null, t.keyof({ a: null, b: null }), false],
	[t.number, t.keyof({ 1: 'foo'}), false],
	[t.partial({ a: t.string }), t.keyof({ a: null, b: null }), false],
	[t.readonlyArray(t.string), t.keyof({ a: null, b: null }), false],
	[t.readonly(t.literal('a')), t.keyof({ a: null, b: null }), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.keyof({ a: null, b: null }), false],
	[t.brand(t.keyof({ a: null, b: null }), (x): x is t.Branded<keyof { a: null, b: null }, Brand> => true, 'Brand'), t.keyof({ a: null, b: null }), true],
	[t.string, t.keyof({ a: null, b: null }), false],
	[t.tuple([t.string, t.number]), t.keyof({ a: null, b: null }), false],
	[t.undefined, t.keyof({ a: null, b: null }), false],
	[t.union([t.literal('a'), t.literal('b')]), t.keyof({ a: null, b: null }), true],
	[t.union([t.literal('a'), t.literal('b'), t.literal('c')]), t.keyof({ a: null, b: null }), false],
	[t.unknown, t.keyof({ a: null, b: null }), false],
	[t.void, t.keyof({ a: null, b: null }), false],
	[t.nullable(t.keyof({ a: null, b: null })), t.keyof({ a: null, b: null }), false],
	[t.promise(t.keyof({ a: null, b: null })), t.keyof({ a: null, b: null }), false],

	// t.LiteralType
	[new t.AnyArrayType, t.literal(5), false],
	[new t.AnyDictionaryType, t.literal(5), false],
	[t.any, t.literal(5), false],
	[t.array(t.unknown), t.literal(5), false],
	[t.bigint, t.literal(5), false],
	[t.boolean, t.literal(5), false],
	[myClss, t.literal(5), false],
	[t.record(t.string, t.string), t.literal(5), false],
	[t.exact(t.type({ a: t.string })), t.literal(5), false],
	[t.fn([['a', t.string]] as const, t.boolean), t.literal(5), false],
	[t.type({ a: t.string }), t.literal(5), false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.literal(5), false],
	[t.keyof({ a: null, b: null }), t.literal(5), false],
	[t.keyof({ 's': null }), t.literal('s'), true],
	[t.literal(5), t.literal(5), true],
	[t.literal('s'), t.literal(5), false],
	[t.never, t.literal(5), true],
	[t.null, t.literal(5), false],
	[t.number, t.literal(5), false],
	[t.partial({ a: t.string }), t.literal(5), false],
	[t.readonlyArray(t.string), t.literal(5), false],
	[t.readonly(t.literal(5)), t.literal(5), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.literal(5), false],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.literal(5), false],
	[t.string, t.literal(5), false],
	[t.tuple([t.string, t.number]), t.literal(5), false],
	[t.undefined, t.literal(5), false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.literal(5), false],
	[t.unknown, t.literal(5), false],
	[t.void, t.literal(5), false],
	[t.nullable(t.literal(5)), t.literal(5), false],
	[t.promise(t.literal(5)), t.literal(5), false],

	// t.never
	[new t.AnyArrayType, t.never, false],
	[new t.AnyDictionaryType, t.never, false],
	[t.any, t.never, false],
	[t.array(t.unknown), t.never, false],
	[t.bigint, t.never, false],
	[myClss, t.never, false],
	[t.boolean, t.never, false],
	[t.record(t.string, t.string), t.never, false],
	[t.exact(t.type({ a: t.string })), t.never, false],
	[t.fn([['a', t.string]] as const, t.boolean), t.never, false],
	[t.type({ a: t.string }), t.never, false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.never, false],
	[t.intersection([t.string, t.number]), t.never, true],
	[t.intersection([t.array(t.string), t.array(t.number)]), t.never, false],
	[t.intersection([t.type({ a: t.string }), t.union([t.type({a: t.number}), t.type({b: t.string})])]), t.never, false],
	[t.keyof({ a: null, b: null }), t.never, false],
	[t.literal('a'), t.never, false],
	[t.never, t.never, true],
	[t.null, t.never, false],
	[t.number, t.never, false],
	[t.partial({ a: t.string }), t.never, false],
	[t.readonlyArray(t.string), t.never, false],
	[t.readonly(t.never), t.never, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.never, false],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.never, false],
	[t.string, t.never, false],
	[t.tuple([t.string, t.number]), t.never, false],
	[t.undefined, t.never, false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.never, false],
	[t.union([t.never, t.never]), t.never, true],
	[t.unknown, t.never, false],
	[t.void, t.never, false],
	[t.nullable(t.never), t.never, false],
	[t.promise(t.never), t.never, false],

	// t.null
	[new t.AnyArrayType, t.null, false],
	[new t.AnyDictionaryType, t.null, false],
	[t.any, t.null, false],
	[t.array(t.unknown), t.null, false],
	[t.bigint, t.null, false],
	[t.boolean, t.null, false],
	[myClss, t.null, false],
	[t.record(t.string, t.string), t.null, false],
	[t.exact(t.type({ a: t.string })), t.null, false],
	[t.fn([['a', t.string]] as const, t.boolean), t.null, false],
	[t.type({ a: t.string }), t.null, false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.null, false],
	[t.keyof({ a: null, b: null }), t.null, false],
	[t.literal('a'), t.null, false],
	[t.never, t.null, true],
	[t.null, t.null, true],
	[t.number, t.null, false],
	[t.partial({ a: t.string }), t.null, false],
	[t.readonlyArray(t.string), t.null, false],
	[t.readonly(t.null), t.null, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.null, false],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.null, false],
	[t.string, t.null, false],
	[t.tuple([t.string, t.number]), t.null, false],
	[t.undefined, t.null, false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.null, false],
	[t.unknown, t.null, false],
	[t.void, t.null, false],
	[t.nullable(t.null), t.null, false],
	[t.promise(t.null), t.null, false],

	// t.NullableType
	[new t.AnyArrayType, t.nullable(new t.AnyArrayType), true],
	[new t.AnyDictionaryType, t.nullable(new t.AnyDictionaryType), true],
	[t.any, t.nullable(t.any), true],
	[t.array(t.unknown), t.nullable(t.array(t.unknown)), true],
	[t.bigint, t.nullable(t.bigint), true],
	[t.boolean, t.nullable(t.boolean), true],
	[myClss, t.nullable(myClss), true],
	[t.record(t.string, t.string), t.nullable(t.record(t.string, t.string)), true],
	[t.exact(t.type({ a: t.string })), t.nullable(t.exact(t.type({ a: t.string }))), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.nullable(t.fn([['a', t.string]] as const, t.boolean)), true],
	[t.type({ a: t.string }), t.nullable(t.type({ a: t.string })), true],
	[t.intersection([t.unknown, t.nullable(t.string)]), t.nullable(t.intersection([t.unknown, t.nullable(t.string)])), true],
	[t.keyof({ a: null, b: null }), t.nullable(t.keyof({ a: null, b: null })), true],
	[t.literal('a'), t.nullable(t.literal('a')), true],
	[t.never, t.nullable(t.never), true],
	[t.null, t.nullable(t.null), true],
	[t.number, t.nullable(t.number), true],
	[t.partial({ a: t.string }), t.nullable(t.partial({ a: t.string })), true],
	[t.readonlyArray(t.string), t.nullable(t.readonlyArray(t.string)), true],
	[t.readonly(t.nullable(t.string)), t.nullable(t.string), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.nullable(t.recursion('T', (self) => t.type({ a: t.string, b: self }))), true],
	[t.brand(t.nullable(t.string), (x): x is t.Branded<string, Brand> => true, 'Brand'), t.nullable(t.brand(t.nullable(t.string), (x): x is t.Branded<string, Brand> => true, 'Brand')), true],
	[t.string, t.nullable(t.string), true],
	[t.tuple([t.string, t.number]), t.nullable(t.tuple([t.string, t.number])), true],
	[t.undefined, t.nullable(t.undefined), true],
	[t.union([t.never, t.nullable(t.string)]), t.nullable(t.union([t.never, t.nullable(t.string)])), true],
	[t.union([t.string, t.nullable(t.string)]), t.nullable(t.nullable(t.string)), true],
	[t.unknown, t.nullable(t.unknown), true],
	[t.nullable(t.string), t.nullable(t.nullable(t.string)), true],
	[t.promise(t.nullable(t.string)), t.nullable(t.promise(t.nullable(t.string))), true],
	[t.string, t.nullable(t.number), false],

	// t.NumberType
	[new t.AnyArrayType, t.number, false],
	[new t.AnyDictionaryType, t.number, false],
	[t.any, t.number, false],
	[t.array(t.unknown), t.number, false],
	[t.bigint, t.number, false],
	[t.boolean, t.number, false],
	[myClss, t.number, false],
	[t.record(t.string, t.string), t.number, false],
	[t.exact(t.type({ a: t.string })), t.number, false],
	[t.fn([['a', t.string]] as const, t.boolean), t.number, false],
	[t.type({ a: t.string }), t.number, false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.number, false],
	[t.keyof({ a: null, b: null }), t.number, false],
	[t.keyof({ 1: null }), t.number, false],
	[t.literal(5), t.number, true],
	[t.never, t.number, true],
	[t.null, t.number, false],
	[t.number, t.number, true],
	[t.partial({ a: t.string }), t.number, false],
	[t.readonlyArray(t.string), t.number, false],
	[t.readonly(t.number), t.number, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.number, false],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.number, true],
	[t.string, t.number, false],
	[t.tuple([t.string, t.number]), t.number, false],
	[t.undefined, t.number, false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.number, false],
	[t.unknown, t.number, false],
	[t.void, t.number, false],
	[t.nullable(t.number), t.number, false],
	[t.promise(t.number), t.number, false],

	// t.PartialType
	[new t.AnyArrayType, t.partial({ a: t.string, b: t.number}), false],
	[new t.AnyDictionaryType, t.partial({ a: t.string, b: t.number}), false],
	[t.any, t.partial({ a: t.string, b: t.number}), false],
	[t.array(t.unknown), t.partial({ a: t.string, b: t.number}), false],
	[t.bigint, t.partial({ a: t.string, b: t.number}), false],
	[t.boolean, t.partial({ a: t.string, b: t.number}), false],
	[myClss, t.partial({ a: t.string }), true],
	[t.record(t.string, t.string), t.partial({ a: t.string, b: t.number}), false],
	[t.exact(t.type({ a: t.string })), t.partial({ a: t.string, b: t.number}), true],
	[t.exact(t.type({ a: t.string, c: t.boolean })), t.partial({ a: t.string, b: t.number}), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.partial({ a: t.string }), false],
	[t.type({}), t.partial({ a: t.string, b: t.number}), true],
	[t.type({ a: t.undefined }), t.partial({ a: t.string, b: t.number}), true],
	[t.type({ a: t.boolean }), t.partial({ a: t.string, b: t.number}), false],
	[t.type({ a: t.string }), t.partial({ a: t.string, b: t.number}), true],
	[t.type({ a: t.string, c: t.boolean }), t.partial({ a: t.string, b: t.number}), true],
	[t.intersection([t.type({ a: t.string, b: t.unknown }), t.type({ b: t.number, c: t.boolean })]), t.partial({ a: t.string, b: t.number}), true],
	[t.keyof({ a: null, b: null }), t.partial({ a: t.string, b: t.number}), false],
	[t.literal('a'), t.partial({ a: t.string, b: t.number}), false],
	[t.never, t.partial({ a: t.string, b: t.number}), true],
	[t.null, t.partial({ a: t.string, b: t.number}), false],
	[t.number, t.partial({ a: t.string, b: t.number}), false],
	[t.partial({ a: t.string }), t.partial({ a: t.string, b: t.number}), true],
	[t.partial({ a: t.string, b: t.boolean }), t.partial({ a: t.string, b: t.number}), false],
	[t.partial({ a: t.string, c: t.boolean }), t.partial({ a: t.string, b: t.number}), true],
	[t.readonlyArray(t.string), t.partial({ a: t.string, b: t.number}), false],
	[t.readonly(t.type({ a: t.string })), t.partial({ a: t.string, b: t.number}), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.partial({ a: t.string, b: t.type({ a: t.string })}), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: t.union([self, t.undefined]) })), t.partial({ a: t.string, b: t.type({ a: t.string })}), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: t.union([self, t.undefined]) })), t.partial({ a: t.string }), true],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.partial({ a: t.string, b: t.number}), false],
	[t.string, t.partial({ a: t.string, b: t.number}), false],
	[t.tuple([t.string, t.number]), t.partial({ a: t.string, b: t.number}), false],
	[t.undefined, t.partial({ a: t.string, b: t.number}), false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.partial({ a: t.string, b: t.number}), true],
	[t.unknown, t.partial({ a: t.string, b: t.number}), false],
	[t.void, t.partial({ a: t.string, b: t.number}), false],
	[t.nullable(t.partial({ a: t.string, b: t.number})), t.partial({ a: t.string, b: t.number}), false],
	[t.promise(t.partial({ a: t.string, b: t.number})), t.partial({ a: t.string, b: t.number}), false],

	// t.ReadonlyArrayType
	[new t.AnyArrayType, t.readonlyArray(t.string), false],
	[new t.AnyDictionaryType, t.readonlyArray(t.string), false],
	[t.any, t.readonlyArray(t.string), false],
	[t.array(t.unknown), t.readonlyArray(t.string), false],
	[t.array(t.string), t.readonlyArray(t.string), true],
	[t.bigint, t.readonlyArray(t.string), false],
	[t.boolean, t.readonlyArray(t.string), false],
	[myClss, t.readonlyArray(t.string), false],
	[t.record(t.string, t.string), t.readonlyArray(t.string), false],
	[t.exact(t.type({ a: t.string })), t.readonlyArray(t.string), false],
	[t.fn([['a', t.string]] as const, t.boolean), t.readonlyArray(t.string), false],
	[t.type({ a: t.string }), t.readonlyArray(t.string), false],
	[t.intersection([t.array(t.unknown), t.array(t.string)]), t.readonlyArray(t.string), true],
	[t.intersection([t.array(t.unknown), t.readonlyArray(t.string)]), t.readonlyArray(t.string), true],
	[t.keyof({ a: null, b: null }), t.readonlyArray(t.string), false],
	[t.literal('a'), t.readonlyArray(t.string), false],
	[t.never, t.readonlyArray(t.string), true],
	[t.null, t.readonlyArray(t.string), false],
	[t.number, t.readonlyArray(t.string), false],
	[t.partial({ a: t.string }), t.readonlyArray(t.string), false],
	[t.readonlyArray(t.string), t.readonlyArray(t.string), true],
	[t.readonlyArray(t.number), t.readonlyArray(t.string), false],
	[t.readonly(t.array(t.string)), t.readonlyArray(t.string), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.readonlyArray(t.string), false],
	[t.recursion('T', (self) => t.readonlyArray(t.union([self, t.string]))), t.recursion('T', (self) => t.readonlyArray(t.union([self, t.string, t.number]))), true],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.readonlyArray(t.string), false],
	[t.string, t.readonlyArray(t.string), false],
	[t.tuple([t.string, t.number]), t.readonlyArray(t.string), false],
	[t.tuple([t.string, t.string]), t.readonlyArray(t.string), true],
	[t.undefined, t.readonlyArray(t.string), false],
	[t.union([t.array(t.string), t.readonlyArray(t.string), t.tuple([t.string, t.literal('s')])]), t.readonlyArray(t.string), true],
	[t.unknown, t.readonlyArray(t.string), false],
	[t.void, t.readonlyArray(t.string), false],
	[t.nullable(t.readonlyArray(t.string)), t.readonlyArray(t.string), false],
	[t.promise(t.readonlyArray(t.string)), t.readonlyArray(t.string), false],

	// t.ReadonlyType
	[new t.AnyArrayType, t.readonly(new t.AnyArrayType), true],
	[new t.AnyDictionaryType, t.readonly(new t.AnyDictionaryType), true],
	[t.any, t.readonly(t.any), true],
	[t.array(t.unknown), t.readonly(t.array(t.unknown)), true],
	[t.bigint, t.readonly(t.bigint), true],
	[t.boolean, t.readonly(t.boolean), true],
	[myClss, t.readonly(t.type({ a: t.string })), true],
	[t.record(t.string, t.string), t.readonly(t.record(t.string, t.string)), true],
	[t.exact(t.type({ a: t.string })), t.readonly(t.exact(t.type({ a: t.string }))), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.readonly(t.fn([['a', t.string]] as const, t.boolean)), true],
	[t.type({ a: t.string }), t.readonly(t.type({ a: t.string })), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.readonly(t.intersection([t.type({ a: t.string }), t.type({ b: t.number })])), true],
	[t.keyof({ a: null, b: null }), t.readonly(t.keyof({ a: null, b: null })), true],
	[t.literal('a'), t.readonly(t.literal('a')), true],
	[t.never, t.readonly(t.never), true],
	[t.null, t.readonly(t.null), true],
	[t.number, t.readonly(t.number), true],
	[t.partial({ a: t.string }), t.readonly(t.partial({ a: t.string })), true],
	[t.readonlyArray(t.string), t.readonly(t.readonlyArray(t.string)), true],
	[t.readonly(t.type({ a: t.string })), t.readonly(t.type({ a: t.string })), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.readonly(t.recursion('T', (self) => t.type({ a: t.string, b: self }))), true],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.readonly(t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand')), true],
	[t.string, t.readonly(t.string), true],
	[t.tuple([t.string, t.number]), t.readonly(t.tuple([t.string, t.number])), true],
	[t.undefined, t.readonly(t.undefined), true],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.readonly(t.union([t.type({ a: t.string }), t.type({ b: t.number })])), true],
	[t.unknown, t.readonly(t.unknown), true],
	[t.void, t.readonly(t.void), true],
	[t.nullable(t.readonly(t.void)), t.readonly(t.nullable(t.void)), true],
	[t.nullable(t.readonly(t.void)), t.readonly(t.void), false],
	[t.promise(t.readonly(t.void)), t.readonly(t.promise(t.void)), true],
	[t.promise(t.readonly(t.void)), t.readonly(t.void), false],

	// t.RecursiveType
	[new t.AnyArrayType, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[new t.AnyDictionaryType, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.any, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.array(t.string), t.recursion('T', (self) => t.array(t.union([t.string, self]))), true],
	[t.array(t.array(t.array(t.string))), t.recursion('T', (self) => t.array(t.union([t.string, self]))), true],
	[t.array(t.unknown), t.recursion('T', (self) => t.array(t.union([t.string, self]))), false],
	[t.bigint, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.boolean, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[myClss, t.recursion('U', (self) => t.type({ a: t.string, d: self })), false],
	[t.record(t.string, t.string), t.recursion('T', (self) => t.record(t.string, t.union([self, t.string]))), true],
	[t.record(t.string, t.record(t.string, t.record(t.string, t.string))), t.recursion('T', (self) => t.record(t.string, t.union([self, t.string]))), true],
	[t.exact(t.type({ a: t.string })), t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.recursion('T', (self) => t.fn([['a', t.string], ['b', self]] as const, t.boolean)), t.recursion('U', (self) => t.fn([['a', t.string], ['b', self]] as const, t.boolean)), true],
	[t.recursion('T', (self) => t.fn([['a', t.string]] as const, t.boolean)), t.recursion('V', (self) => t.fn([['a', t.string], ['b', self]] as const, t.boolean)), true],
	[t.recursion('T', (self) => t.fn([['a', t.string], ['b', t.fn([['a', t.string]] as const, t.boolean)]] as const, t.boolean)), t.recursion('W', (self) => t.fn([['a', t.string], ['b', self]] as const, t.boolean)), true],
	[t.type({ a: t.string, b: t.type({ a: t.string, b: t.number }) }), t.recursion('T', (self) => t.type({ a: t.string, b: t.union([self, t.number]) })), true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.recursion('T', (self) => t.type({ a: t.string, b: t.union([self, t.number]) })), true],
	[t.keyof({ a: null, b: null }), t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.literal('a'), t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.never, t.recursion('T', (self) => t.type({ a: t.string, b: self })), true],
	[t.null, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.number, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.partial({ a: t.string }), t.recursion('T', (self) => t.partial({ a: t.string, b: self })), true],
	[t.partial({ a: t.string, b: t.type({ a: t.string, b: t.number }) }), t.recursion('T', (self) => t.partial({ a: t.string, b: t.union([self, t.number]) })), true],
	[t.readonlyArray(t.readonlyArray(t.readonlyArray(t.string))), t.recursion('T', (self) => t.readonlyArray(t.union([t.string, self]))), true],
	[t.readonly(t.recursion('T', (self) => t.type({ a: t.string, b: self }))), t.recursion('T', (self) => t.type({ a: t.string, b: self })), true],
	[t.readonly(t.recursion('T', (self) => t.tuple([t.string, self]))), t.recursion('T', (self) => t.tuple([t.string, self])), false],
	[t.readonly(t.type({ a: t.string })), t.recursion('T', (self) => t.type({ a: t.string, b: t.union([self, t.type({ a: t.string })]) })), false],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.recursion('T', (self) => t.type({ a: t.string, b: self })), true],
	[t.brand(t.type({ a: t.string, b: t.type({ a: t.string }) }), (x): x is t.Branded<{ a: string, b: { a: string }}, Brand> => true, 'Brand'), t.recursion('T', (self) => t.type({ a: t.string, b: t.union([self, t.type({ a: t.string })]) })), true],
	[t.string, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.tuple([t.tuple([t.tuple([t.string, t.string]), t.string]), t.string]), t.recursion('T', (self) => t.tuple([t.union([self, t.string]), t.string])), true],
	[t.tuple([t.tuple([t.tuple([t.string, t.number]), t.string]), t.string]), t.recursion('T', (self) => t.tuple([t.union([self, t.string]), t.string])), false],
	[t.undefined, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.union([t.type({ a: t.string }), t.never]), t.recursion('T', (self) => t.type({ a: t.string })), true],
	[t.unknown, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.void, t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.nullable(t.recursion('T', (self) => t.type({ a: t.string, b: self }))), t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],
	[t.promise(t.recursion('T', (self) => t.type({ a: t.string, b: self }))), t.recursion('T', (self) => t.type({ a: t.string, b: self })), false],

	// t.RefinementType
	[new t.AnyArrayType, t.brand(new t.AnyArrayType, (x): x is t.Branded<unknown[], Brand> => true, 'Brand'), false],
	[new t.AnyDictionaryType, t.brand(new t.AnyDictionaryType, (x): x is t.Branded<Record<string, unknown>, Brand> => true, 'Brand'), false],
	[t.any, t.brand(t.any, (x): x is t.Branded<any, Brand> => true, 'Brand'), false],
	[t.array(t.unknown), t.brand(t.array(t.unknown), (x): x is t.Branded<unknown[], Brand> => true, 'Brand'), false],
	[t.bigint, t.brand(t.bigint, (x): x is t.Branded<bigint, Brand> => true, 'Brand'), false],
	[t.boolean, t.brand(t.boolean, (x): x is t.Branded<boolean, Brand> => true, 'Brand'), false],
	[t.brand(myClss, (x): x is t.Branded<{ a: string, b(a: string): boolean, c: boolean }, Brand> => true, 'Brand'), t.brand(myClss, (x): x is t.Branded<{ a: string, b(a: string): boolean, c: boolean }, Brand> => true, 'Brand'), true],
	[t.record(t.string, t.string), t.brand(t.record(t.string, t.string), (x): x is t.Branded<Record<string, string>, Brand> => true, 'Brand'), false],
	[t.exact(t.type({ a: t.string })), t.brand(t.type({ a: t.string }), (x): x is t.Branded<{ a: string }, Brand> => true, 'Brand'), false],
	[t.type({ a: t.string }), t.brand(t.type({ a: t.string }), (x): x is t.Branded<{ a: string }, Brand> => true, 'Brand'), false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.brand(t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), (x): x is t.Branded<{ a: string} & { b: number }, Brand> => true, 'Brand'), false],
	[t.keyof({ a: null, b: null }), t.brand(t.keyof({ a: null, b: null }), (x): x is t.Branded<keyof { a: null, b: null }, Brand> => true, 'Brand'), false],
	[t.literal('a'), t.brand(t.literal('a'), (x): x is t.Branded<'a', Brand> => true, 'Brand'), false],
	[t.never, t.brand(t.never, (x): x is t.Branded<never, Brand> => true, 'Brand'), true],
	[t.null, t.brand(t.null, (x): x is t.Branded<null, Brand> => true, 'Brand'), false],
	[t.number, t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), false],
	[t.partial({ a: t.string }), t.brand(t.partial({ a: t.string }), (x): x is t.Branded<Partial<{ a: string }>, Brand> => true, 'Brand'), false],
	[t.readonlyArray(t.string), t.brand(t.readonlyArray(t.string), (x): x is t.Branded<readonly string[], Brand> => true, 'Brand'), false],
	[t.readonly(t.brand(t.readonly(t.type({ a: t.string })), (x): x is t.Branded<Readonly<{ a: string }>, Brand> => true, 'Brand')), t.brand(t.readonly(t.type({ a: t.string })), (x): x is t.Branded<Readonly<{ a: string }>, Brand> => true, 'Brand'), true],
	[t.readonly(t.brand(t.readonly(t.tuple([t.string])), (x): x is t.Branded<Readonly<[string]>, Brand> => true, 'Brand')), t.brand(t.readonly(t.tuple([t.string])), (x): x is t.Branded<Readonly<[string]>, Brand> => true, 'Brand'), true],
	[t.readonly(t.brand(t.readonly(t.tuple([t.string])), (x): x is t.Branded<Readonly<[string]>, Brand> => true, 'Brand')), t.brand(t.tuple([t.string]), (x): x is t.Branded<[string], Brand> => true, 'Brand'), false],
	[t.recursion('T', (self) => t.type({ a: t.string, b: t.union([self, t.number]) })), t.brand(t.recursion('T', (self) => t.type({ a: t.string, b: t.union([self, t.number]) })), (x): x is t.Branded<T, Brand> => true, 'Brand'), false],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => false, 'Brand'), t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), true],
	[t.intersection([t.number, t.brand(t.number, (x): x is t.Branded<number, Brand> => false, 'Brand')]), t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), true],
	[t.union([t.number, t.brand(t.number, (x): x is t.Branded<number, Brand> => false, 'Brand')]), t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), false],
	[t.string, t.brand(t.string, (x): x is t.Branded<string, Brand> => true, 'Brand'), false],
	[t.tuple([t.string, t.number]), t.brand(t.tuple([t.string, t.number]), (x): x is t.Branded<[string, number], Brand> => true, 'Brand'), false],
	[t.undefined, t.brand(t.undefined, (x): x is t.Branded<undefined, Brand> => true, 'Brand'), false],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.brand(t.union([t.type({ a: t.string }), t.type({ b: t.number })]), (x): x is t.Branded<{ a: string } | { b: number }, Brand> => true, 'Brand'), false],
	[t.unknown, t.brand(t.unknown, (x): x is t.Branded<unknown, Brand> => true, 'Brand'), false],
	[t.void, t.brand(t.void, (x): x is t.Branded<void, Brand> => true, 'Brand'), false],
	[t.nullable(t.brand(t.void, (x): x is t.Branded<void, Brand> => true, 'Brand')), t.brand(t.void, (x): x is t.Branded<void, Brand> => true, 'Brand'), false],
	[t.promise(t.brand(t.void, (x): x is t.Branded<void, Brand> => true, 'Brand')), t.brand(t.void, (x): x is t.Branded<void, Brand> => true, 'Brand'), false],

	// t.string
	[new t.AnyArrayType, t.string, false],
	[new t.AnyDictionaryType, t.string, false],
	[t.any, t.string, false],
	[t.array(t.unknown), t.string, false],
	[t.bigint, t.string, false],
	[t.boolean, t.string, false],
	[myClss, t.string, false],
	[t.record(t.string, t.string), t.string, false],
	[t.exact(t.type({ a: t.string })), t.string, false],
	[t.fn([['a', t.string]] as const, t.boolean), t.string, false],
	[t.type({ a: t.string }), t.string, false],
	[t.intersection([t.string, t.unknown]), t.string, true],
	[t.keyof({ a: null, b: null, 1: null }), t.string, true],
	[t.literal('a'), t.string, true],
	[t.never, t.string, true],
	[t.null, t.string, false],
	[t.number, t.string, false],
	[t.partial({ a: t.string }), t.string, false],
	[t.readonlyArray(t.string), t.string, false],
	[t.readonly(t.string), t.string, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.string, false],
	[t.brand(t.string, (x): x is t.Branded<string, Brand> => true, 'Brand'), t.string, true],
	[t.string, t.string, true],
	[t.tuple([t.string, t.number]), t.string, false],
	[t.undefined, t.string, false],
	[t.union([t.literal('s'), t.string]), t.string, true],
	[t.union([t.literal('s'), t.number]), t.string, false],
	[t.unknown, t.string, false],
	[t.void, t.string, false],
	[t.nullable(t.string), t.string, false],
	[t.promise(t.string), t.string, false],

	// t.TupleType
	[new t.AnyArrayType, t.tuple([t.string, t.number]), false],
	[new t.AnyDictionaryType, t.tuple([t.string, t.number]), false],
	[t.any, t.tuple([t.string, t.number]), false],
	[t.array(t.union([t.string, t.number])), t.tuple([t.string, t.number]), false],
	[t.bigint, t.tuple([t.string, t.number]), false],
	[t.boolean, t.tuple([t.string, t.number]), false],
	[myClss, t.tuple([t.string]), false],
	[t.record(t.string, t.string), t.tuple([t.string, t.number]), false],
	[t.exact(t.type({ a: t.string })), t.tuple([t.string, t.number]), false],
	[t.fn([['a', t.string]] as const, t.boolean), t.tuple([t.string, t.number]), false],
	[t.type({ a: t.string }), t.tuple([t.string, t.number]), false],
	[t.intersection([t.tuple([t.string, t.unknown]), t.tuple([t.unknown, t.number])]), t.tuple([t.string, t.number]), true],
	[t.keyof({ a: null, b: null }), t.tuple([t.string, t.number]), false],
	[t.literal('a'), t.tuple([t.string, t.number]), false],
	[t.never, t.tuple([t.string, t.number]), true],
	[t.null, t.tuple([t.string, t.number]), false],
	[t.number, t.tuple([t.string, t.number]), false],
	[t.partial({ a: t.string }), t.tuple([t.string, t.number]), false],
	[t.readonlyArray(t.union([t.string, t.number])), t.tuple([t.string, t.number]), false],
	[t.readonly(t.tuple([t.string, t.number])), t.tuple([t.string, t.number]), false],
	[t.recursion('T', (self) => t.tuple([t.string, t.union([t.number, self])])), t.tuple([t.string, t.number]), false],
	[t.recursion('T', (self) => t.tuple([t.string, t.union([t.number, self])])), t.recursion('T', (self) => t.tuple([t.string, t.union([t.number, self, t.boolean])])), true],
	[t.brand(t.tuple([t.string, t.number]), (x): x is t.Branded<[string, number], Brand> => true, 'Brand'), t.tuple([t.string, t.number]), true],
	[t.string, t.tuple([t.string, t.number]), false],
	[t.tuple([t.string, t.number]), t.tuple([t.string, t.number]), true],
	[t.tuple([t.string, t.number, t.unknown]), t.tuple([t.string, t.number]), false],
	[t.tuple([t.string]), t.tuple([t.string, t.number]), false],
	[t.undefined, t.tuple([t.string, t.number]), false],
	[t.union([t.tuple([t.string, t.number]), t.tuple([t.string, t.number])]), t.tuple([t.string, t.number]), true],
	[t.unknown, t.tuple([t.string, t.number]), false],
	[t.void, t.tuple([t.string, t.number]), false],
	[t.nullable(t.tuple([t.string, t.number])), t.tuple([t.string, t.number]), false],
	[t.promise(t.tuple([t.string, t.number])), t.tuple([t.string, t.number]), false],

	// t.UndefinedType
	[new t.AnyArrayType, t.undefined, false],
	[new t.AnyDictionaryType, t.undefined, false],
	[t.any, t.undefined, false],
	[t.array(t.unknown), t.undefined, false],
	[t.bigint, t.undefined, false],
	[t.boolean, t.undefined, false],
	[myClss, t.undefined, false],
	[t.record(t.string, t.string), t.undefined, false],
	[t.exact(t.type({ a: t.string })), t.undefined, false],
	[t.fn([['a', t.string]] as const, t.boolean), t.undefined, false],
	[t.type({ a: t.string }), t.undefined, false],
	[t.intersection([t.undefined, t.unknown]), t.undefined, true],
	[t.keyof({ a: null, b: null }), t.undefined, false],
	[t.literal('a'), t.undefined, false],
	[t.never, t.undefined, true],
	[t.null, t.undefined, false],
	[t.number, t.undefined, false],
	[t.partial({ a: t.string }), t.undefined, false],
	[t.readonlyArray(t.string), t.undefined, false],
	[t.readonly(t.undefined), t.undefined, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.undefined, false],
	[t.brand(t.undefined, (x): x is t.Branded<undefined, Brand> => true, 'Brand'), t.undefined, true],
	[t.string, t.undefined, false],
	[t.tuple([t.string, t.number]), t.undefined, false],
	[t.undefined, t.undefined, true],
	[t.union([t.never, t.undefined]), t.undefined, true],
	[t.unknown, t.undefined, false],
	[t.void, t.undefined, false],
	[t.nullable(t.undefined), t.undefined, false],
	[t.promise(t.undefined), t.undefined, false],

	// t.UnionType
	[new t.AnyArrayType, t.union([t.never, new t.AnyArrayType]), true],
	[new t.AnyDictionaryType, t.union([t.never, new t.AnyDictionaryType]), true],
	[t.any, t.union([t.never, t.any]), true],
	[t.array(t.unknown), t.union([t.never, new t.AnyArrayType]), true],
	[t.bigint, t.union([t.never, t.bigint]), true],
	[t.boolean, t.union([t.never, t.boolean]), true],
	[myClss, t.union([myClss, t.never]), true],
	[t.record(t.string, t.string), t.union([t.never, t.record(t.string, t.string)]), true],
	[t.exact(t.type({ a: t.string })), t.union([t.never, t.type({ a: t.string })]), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.union([t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.string]] as const, t.boolean)]), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.union([t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.literal('s')]] as const, t.boolean)]), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.union([t.fn([['a', t.string]] as const, t.boolean), t.fn([['a', t.unknown]] as const, t.boolean)]), true],
	[t.fn([['a', t.string]] as const, t.boolean), t.union([t.fn([['a', t.unknown]] as const, t.boolean), t.fn([['a', t.unknown]] as const, t.boolean)]), true],
	[t.type({ a: t.string, b: t.number }), t.union([t.type({ a: t.never, b: t.number }), t.type({ a: t.string, b: t.never })]), false],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.union([t.type({ a: t.never, b: t.number }), t.type({ a: t.string, b: t.never })]), false],
	[t.keyof({ a: null, b: null }), t.union([t.never, t.literal('a'), t.literal('b')]), true],
	[t.keyof({ a: null, b: null, c: null }), t.union([t.never, t.literal('a'), t.literal('b')]), false],
	[t.literal('a'), t.union([t.never, t.literal('a')]), true],
	[t.never, t.union([t.never, t.never]), true],
	[t.null, t.union([t.never, t.null]), true],
	[t.number, t.union([t.never, t.number]), true],
	[t.partial({ a: t.string }), t.union([t.partial({ a: t.never, b: t.number }), t.partial({ a: t.string, b: t.never })]), true],
	[t.partial({ a: t.string, b: t.boolean }), t.union([t.partial({ a: t.never, b: t.number }), t.partial({ a: t.string, b: t.never })]), false],
	[t.readonlyArray(t.string), t.union([t.never, t.readonlyArray(t.string)]), true],
	[t.readonly(t.type({ a: t.string })), t.union([t.never, t.readonly(t.type({ a: t.string }))]), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.union([t.never, t.type({ a: t.string, b: t.type({ a: t.string }) })]), true],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.union([t.never, t.number]), true],
	[t.string, t.union([t.never, t.string]), true],
	[t.tuple([t.string, t.number]), t.union([t.tuple([t.never, t.number]), t.tuple([t.string, t.never])]), false],
	[t.undefined, t.union([t.never, t.undefined]), true],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.union([t.type({ a: t.string }), t.type({ b: t.number })]), true],
	[t.unknown, t.union([t.never, t.unknown]), true],
	[t.void, t.union([t.never, t.void]), true],
	[t.nullable(t.union([t.never, t.string])), t.union([t.never, t.string]), false],
	[t.nullable(t.union([t.never, t.string])), t.union([t.never, t.string, t.null, t.undefined]), true],
	[t.promise(t.union([t.never, t.string])), t.union([t.never, t.string]), false],
	[t.promise(t.string), t.union([t.promise(t.string), t.string]), true],

	// t.UnknownType
	[new t.AnyArrayType, t.unknown, true],
	[new t.AnyDictionaryType, t.unknown, true],
	[t.any, t.unknown, true],
	[t.array(t.unknown), t.unknown, true],
	[t.bigint, t.unknown, true],
	[t.boolean, t.unknown, true],
	[myClss, t.union([myClss, t.unknown]), true],
	[t.record(t.string, t.string), t.unknown, true],
	[t.exact(t.type({ a: t.string })), t.unknown, true],
	[t.fn([['a', t.string]] as const, t.boolean), t.unknown, true],
	[t.type({ a: t.string }), t.unknown, true],
	[t.intersection([t.type({ a: t.string }), t.type({ b: t.number })]), t.unknown, true],
	[t.keyof({ a: null, b: null }), t.unknown, true],
	[t.literal('a'), t.unknown, true],
	[t.never, t.unknown, true],
	[t.null, t.unknown, true],
	[t.number, t.unknown, true],
	[t.partial({ a: t.string }), t.unknown, true],
	[t.readonlyArray(t.string), t.unknown, true],
	[t.readonly(t.type({ a: t.string })), t.unknown, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.unknown, true],
	[t.brand(t.number, (x): x is t.Branded<number, Brand> => true, 'Brand'), t.unknown, true],
	[t.string, t.unknown, true],
	[t.tuple([t.string, t.number]), t.unknown, true],
	[t.undefined, t.unknown, true],
	[t.union([t.type({ a: t.string }), t.type({ b: t.number })]), t.unknown, true],
	[t.unknown, t.unknown, true],
	[t.void, t.unknown, true],
	[t.nullable(t.unknown), t.unknown, true],
	[t.promise(t.unknown), t.unknown, true],

	// t.VoidType
	[new t.AnyArrayType, t.void, false],
	[new t.AnyDictionaryType, t.void, false],
	[t.any, t.void, false],
	[t.array(t.unknown), t.void, false],
	[t.bigint, t.void, false],
	[t.boolean, t.void, false],
	[myClss, t.void, false],
	[t.record(t.string, t.string), t.void, false],
	[t.exact(t.type({ a: t.string })), t.void, false],
	[t.fn([['a', t.string]] as const, t.boolean), t.void, false],
	[t.type({ a: t.string }), t.void, false],
	[t.intersection([t.unknown, t.void]), t.void, true],
	[t.keyof({ a: null, b: null }), t.void, false],
	[t.literal('a'), t.void, false],
	[t.never, t.void, true],
	[t.null, t.void, false],
	[t.number, t.void, false],
	[t.partial({ a: t.string }), t.void, false],
	[t.readonlyArray(t.string), t.void, false],
	[t.readonly(t.void), t.void, true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.void, false],
	[t.brand(t.void, (x): x is t.Branded<void, Brand> => true, 'Brand'), t.void, true],
	[t.string, t.void, false],
	[t.tuple([t.string, t.number]), t.void, false],
	[t.undefined, t.void, true],
	[t.union([t.never, t.void]), t.void, true],
	[t.unknown, t.void, false],
	[t.void, t.void, true],
	[t.nullable(t.void), t.void, false],
	[t.promise(t.void), t.void, false],

	// t.PromiseType
	[new t.AnyArrayType, t.promise(new t.AnyArrayType), false],
	[new t.AnyDictionaryType, t.promise(new t.AnyDictionaryType), false],
	[t.any, t.promise(t.any), false],
	[t.array(t.unknown), t.promise(t.array(t.unknown)), false],
	[t.bigint, t.promise(t.bigint), false],
	[t.boolean, t.promise(t.boolean), false],
	[myClss, t.promise(myClss), false],
	[t.record(t.string, t.string), t.promise(t.record(t.string, t.string)), false],
	[t.exact(t.type({ a: t.string })), t.promise(t.exact(t.type({ a: t.string }))), false],
	[t.fn([['a', t.string]] as const, t.boolean), t.promise(t.fn([['a', t.string]] as const, t.boolean)), false],
	[t.type({ a: t.string }), t.promise(t.type({ a: t.string })), false],
	[t.intersection([t.unknown, t.promise(t.unknown)]), t.promise(t.intersection([t.unknown, t.promise(t.unknown)])), false],
	[t.intersection([t.unknown, t.promise(t.promise(t.unknown))]), t.promise(t.intersection([t.unknown, t.promise(t.unknown)])), true],
	[t.keyof({ a: null, b: null }), t.promise(t.keyof({ a: null, b: null })), false],
	[t.literal('a'), t.promise(t.literal('a')), false],
	[t.never, t.promise(t.never), true],
	[t.null, t.promise(t.null), false],
	[t.number, t.promise(t.number), false],
	[t.partial({ a: t.string }), t.promise(t.partial({ a: t.string })), false],
	[t.readonlyArray(t.string), t.promise(t.readonlyArray(t.string)), false],
	[t.readonly(t.promise(t.string)), t.promise(t.readonly(t.promise(t.string))), false],
	[t.readonly(t.promise(t.promise(t.string))), t.promise(t.readonly(t.promise(t.string))), true],
	[t.recursion('T', (self) => t.type({ a: t.string, b: self })), t.promise(t.recursion('T', (self) => t.type({ a: t.string, b: self }))), false],
	[t.brand(t.promise(t.string), (x): x is t.Branded<Promise<string>, Brand> => true, 'Brand'), t.promise(t.brand(t.promise(t.string), (x): x is t.Branded<Promise<string>, Brand> => true, 'Brand')), false],
	[t.promise(t.brand(t.promise(t.string), (x): x is t.Branded<Promise<string>, Brand> => true, 'Brand')), t.promise(t.brand(t.promise(t.string), (x): x is t.Branded<Promise<string>, Brand> => true, 'Brand')), true],
	[t.string, t.promise(t.string), false],
	[t.tuple([t.string, t.number]), t.promise(t.tuple([t.string, t.number])), false],
	[t.undefined, t.promise(t.undefined), false],
	[t.union([t.never, t.promise(t.union([t.never, t.string]))]), t.promise(t.union([t.never, t.string])), true],
	[t.union([t.string, t.promise(t.union([t.never, t.string]))]), t.promise(t.union([t.never, t.string])), false],
	[t.unknown, t.promise(t.unknown), false],
	[t.promise(t.string), t.promise(t.string), true],
	[t.nullable(t.promise(t.string)), t.promise(t.nullable(t.promise(t.string))), false],
	[t.promise(t.promise(t.string)), t.promise(t.promise(t.promise(t.string))), false],
];

const source = t.union([t.type({ a: t.string }), t.type({ b: t.number })]);
const target = t.record(t.string, t.union([t.string, t.number]));
const test: t.TypeOf<typeof source> extends t.TypeOf<typeof target> ? true : false = true;

for (const [source, target, expected] of tests1.concat(tests2)) {
	const result = t.isExtensionOf(source, target);
	if (result !== expected) {
		throw new Error(`Expected ${(source as any).render()} to ${expected ? '' : 'not '}be extension of ${(target as any).render()}.`);
	}
}
